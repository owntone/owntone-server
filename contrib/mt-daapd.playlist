# $Id$
#
# This is the playlist file, for specifying iTunes-style
# "Smart Playlists".
# 
# The syntax is as follows:
#
# "Playlist Name" { expression }
#
# An expression consists of:
#
# ID3-tag-name operator operand
#
# Where valid ID3-tag-names are:
#   Artist (string)
#   Album (string)
#   Genre (string) 
#   Path (string) -- full path to song, including filename
#   Composer (string)
#   Orchestra (string)
#   Conductor (string)
#   Grouping (string) -- I don't even know what this is...
#   Year (int)
#   BPM (int)
#   Bitrate (int)
#
# Valid operators include:
#   is, includes (string)
#   >, <, <=, >=, = (int)
#
# the "is" operator must exactly match the tag,
# while the "includes" operator matches a substring.
# Both matches are case-insensitive
#
# Valid operands include:
#   "string value" (string)
#   integer (int)
#
# Multiple expressions can be anded or ored together,
# using the keywords OR and AND (or || and &&).
# The unary not operator is also supported using the
# keyword NOT (or !)
#
# Examples:
#
# "techno" {
#    genre includes "techno" ||
#    artist includes "zombie"
# }
#
# This would match songs by "Rob Zombie" or "White Zombie",
# as well as those with a genre of "Techno-Industrial" or
# "Trance/Techno", for example.
#
# "AAC Files" {
#   path includes ".m4a" ||
#   path includes ".m4p"
# }
#
# This would match all m4a and m4p files -- i.e. iTunes-ripped aac files
# or songs downloaded from iTMS.
#
# "Orchestral Music" {
#   Orchestra !IS "" ||
#   Conductor !IS ""
# }
#
# This would match anything with *anything* entered as a
# orchestra or conductor... this would probably include any
# orchestral music.  Kind of ugly, but works!
#
# I expect that this language will grow over time.  If you want
# to hack on it, see src/lexer.l, src/parser.y, and src/playlist.c
#
# If there is something missing you particularly want, let me
# (rpedde@users.sourceforge.net) know!
#

"60's Music" {
	Year > 1959 && Year < 1970
}

"70's Music" {
	Year > 1969 && Year < 1980
}

"80's Music" {
	Year > 1979 && Year < 1990
}

"90's Music" {
	Year > 1989 && Year < 2000
}

"00's Music" {
	Year > 1999
}

